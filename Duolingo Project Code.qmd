---
title: "Duolingo Project Code"
author: "Michael Chrzan, Alexa Sparks, Tracy Li"
format: html
editor: visual
---

# Introduction

Given a history of errors made by learners of a second language, the task is to predict errors that they are likely to make at arbitrary points in the future.

# Research Questions

Our main research question is: What features best predict second-language-learners accuracy rates for correctly identifying a word in a Duolingo exercise?

In addressing that question, we are also considering the following questions:

-   What other user characteristics can we deduce from the provided data? How well do those derived characteristics predict user accuracy?

-   Do certain features better predict word-accuracy versus exercise-accuracy?

# Setup

## Libraries

Which libraries will we use and why?

```{r libraries}
library(tidyverse)
library(skimr)
library(naniar)
library(gt)
library(MASS)
library(caret)
library(vip)
library(rpart.plot)
library(randomForest)
library(FactoMineR)
library(factoextra)
library(corrplot)
```

## Import Data

```{r import-data}
duodata <- read_csv("data_flatformat.csv")
```

# Explore Data

```{r view-data}
glimpse(duodata)
duoskim <- skim(duodata)
duoskim
```

## Missing Data

```{r viz-missing}
#Setting sample since these packaged functions throw errors for large data
set.seed(1234)
duosample <- sample_n(duodata, 2622956/54)

vis_miss(duosample, 
         show_perc = TRUE) 
miss_var_summary(duosample)

duosample_mis <- duosample |> 
  dplyr::select(prompt, time, client, format, session)

gg_miss_var(duosample_mis)
gg_miss_var(duosample_mis, 
            facet = client, 
            show_pct = TRUE)
gg_miss_var(duosample_mis, 
            facet = format, 
            show_pct = TRUE)
gg_miss_var(duosample_mis, 
            facet = session, 
            show_pct = TRUE)
gg_miss_upset(duosample_mis)

```

```{r mis-prompt}
#Examining Missiningness Related to Prompt and Time with Other Variables
#Is all the missing prompt data in format? Appears so (NOTE, not the sample, full dataset)

#Prompt
duodata |> 
  dplyr::select(prompt, format, session, client) |> 
  group_by(format, session, client) |> 
  miss_var_summary() |>
  arrange(desc(pct_miss))

#Time
duodata |> 
  dplyr::select(time, format, session, client) |> 
  group_by(format, session, client) |> 
  miss_var_summary() |>
  arrange(desc(pct_miss))
```

```{r impute-data}
duodata |> 
  dplyr::select(-instance_id, 
                -part_of_speech, 
                -contains('dependency'), 
                -countries) |> 
  group_by(exercise_id) |> 
  mutate(exercise_accuracy = mean(label)) |> 
  ungroup() |> 
  filter(format == 'listen') |> 
  filter(exercise_accuracy == 1) |> 
  mutate(prompt = if_else(is.na(prompt), 'identifiable', prompt))

#If we can get the exact prompt, we can match it to users who got it wrong (ask Sanne!)

#Could we also just remove prompt? 
```

```{r remove-mis-remaining}
#Prompt missing data is entirely on the listen format
#Time missing data seems to mostly be a problem on iOS but Michael can't see a pattern beyond that. 

duodata <- duodata |> 
  dplyr::select(-prompt) |> 
  na.omit()
```

```{r data-manipulations}
#Session Accuracy and Session Time for each User for their entire time
duodata |> 
  group_by(user) |> 
  mutate(avg_accuracy_user = mean(label), 
         avg_session_time_user = mean(time), 
         avg_days_user = mean(days)) |>
  ungroup() |> 
  dplyr::select(user, session_id, exercise_id, contains('avg'))

#Session Accuracy and Session Time per Day
#Is the day variable aligned for each user? i.e. If I skipped 2 days, is my day 2 the same as a continuous user's day 4? 
duodata |> 
  mutate(days_count = round(days)) |>
  group_by(user, days_count) |> 
  mutate(avg_daily_accuracy_user = mean(label), 
         avg_daily_session_time_user = mean(time)) |> 
  ungroup() |> 
  dplyr::select(user, days, session_id, exercise_id, contains('avg'))

#Number of Exercises per Session
duodata |> 
  group_by(session_id) |>
  mutate(num_session_exercises = n_distinct(exercise_index)) |> 
  ungroup() |> 
  group_by(user) |> 
  mutate(avg_exer_per_session = mean(num_session_exercises)) |> 
  ungroup() |> 
  dplyr::select(user, session_id, num_session_exercises, avg_exer_per_session)

  
#Number of Exercises per Day
duodata |> 
  group_by(session_id) |>
  mutate(num_session_exercises = n_distinct(exercise_index)) |> 
  ungroup() |> 
  mutate(days_count = round(days)) |>
  group_by(user, days_count) |> 
  mutate(avg_daily_num_exercise = mean(num_session_exercises)) |> 
  dplyr::select(user, exercise_id, days_count, num_session_exercises, avg_daily_num_exercise)

#Number of Sessions per Day


#Exercise Accuracy??
duodata |> 
  group_by(exercise_id) |> 
  mutate(avg_user_exer_accuracy = mean(label)) |> 
  ungroup() |> 
  dplyr::select(user, exercise_id, avg_user_exer_accuracy)


#Removing Variables Not Included in our final analysis
duodata |> 
  dplyr::select(-countries)
```

```{r viz-variable-dist}
duodata |>
  pivot_longer(cols = c(part_of_speech, 
                        client, 
                        session, 
                        format),
               names_to = "variable",
               values_to = "value") |>
  ggplot() +
  geom_bar(aes(value)) +
  facet_wrap(. ~ variable, 
             scales = "free") + 
  coord_flip()

duodata |>
  pivot_longer(cols = c(dependency_label, 
                        countries),
               names_to = "variable",
               values_to = "value") |>
  ggplot() +
  geom_bar(aes(value)) +
  facet_wrap(. ~ variable, 
             scales = "free") + 
  coord_flip()

duodata |>
  pivot_longer(cols = where(is.numeric), 
               names_to = "variable",
               values_to = "value") |>
  ggplot() +
  geom_histogram(aes(value)) +
  facet_wrap(. ~ variable, 
             scales = "free") 

#Should we include folks at 0 days?
```

```{r check-countries}
distinct(duodata, countries)
#How should we handle multiple countries? 
```

# Examine Data

```{r viz for seminar}
#Create a viz of x = time, y = accuracy measured by proportion of label that is 1
#Could also show if accuracy changes based on session

#SOMETHING VERY STRANGE HAPPENING HERE w/ iOS-------
duosample |> 
  group_by(user, session_id) |> 
  mutate(user_session_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = days, 
             y = user_session_accuracy, 
             color = session)) + 
  geom_smooth() + 
  facet_grid(~client) +
  labs(title = 'User Session Accuracy Over Time', 
       subtitle = '',
       x = 'Session Type', 
       y = 'Session Accuracy') + 
  theme_minimal() 
#--------------------------------------------------

duodata |> 
  group_by(session) |> 
  summarise(session_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = session, 
             y = session_accuracy, 
             fill = session)) + 
  geom_col() +
  scale_fill_manual(values = c('#7ac70c', '#7ac70c', '#7ac70c')) +
  labs(title = 'Practice Makes Perfect?', 
       subtitle = 'Average Session Accuracy based on Session Type',
       x = 'Session Type', 
       y = 'Session Accuracy') + 
  theme_minimal() +
  theme(legend.position = 'none') +
  coord_flip()

duodata |> 
  group_by(session_id) |> 
  mutate(session_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = days, 
             y = session_accuracy, 
             color = session)) + 
  geom_smooth() + 
  labs(title = 'It All Adds Up', 
       subtitle = 'Session Accuracy Over Time',
       x = 'Days Since Starting Duolingo', 
       y = 'Session Accuracy', 
       color = 'Session Type') + 
  theme_minimal() + 
  theme(legend.position = 'bottom')

duodata |> 
  group_by(session_id) |> 
  mutate(session_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = days, 
             y = session_accuracy)) + 
  geom_smooth() + 
  labs(title = 'It All Adds Up', 
       subtitle = 'Session Accuracy Over Time',
       x = 'Days Since Starting Duolingo', 
       y = 'Session Accuracy', 
       color = 'Session Type') + 
  theme_minimal() + 
  theme(legend.position = 'bottom')


#Test Outs------------------------------------------------------
duosample |> 
  group_by(user) |> 
  mutate(user_accuracy = sum(label == 1)/sum(!is.na(label))) |> 
  ungroup() |> 
  ggplot(aes(x = user_accuracy)) +
  geom_histogram() + 
  labs(title = 'Distribution of User Accuracy')


duosample |> 
  group_by(user, exercise_id) |> 
  mutate(user_exer_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = days, 
             y = user_exer_accuracy)) +
  geom_smooth() + 
  labs(title = 'User Exercise Accuracy Over Time')

duosample |> 
  group_by(session_id) |> 
  mutate(avg_session_accuracy = mean(label), 
         avg_session_time = mean(time)) |> 
  ungroup() |> 
  ggplot(aes(x = avg_session_time, 
             y = avg_session_accuracy, 
             color = session)) + 
  geom_smooth() + 
  labs(title = 'Session Accuracy vs Session Length', 
       subtitle = '',
       x = 'Average Time for the Session', 
       y = 'Average Session Accuracy', 
       color = 'Session Type') + 
  theme_minimal() +
  theme(legend.position = 'bottom')

#What parts of speech do people most get wrong??
```

```{r pca}
duo_pca <- PCA(dplyr::select(duodata, where(is.numeric)))
```

```{r examine-PCA}
get_eigenvalue(duo_pca)
fviz_eig(duo_pca, addlabels = TRUE)

var <- get_pca_var(duo_pca)
corrplot(var$cor, tl.col = "black", method = "color")

var$cos2
corrplot(var$cos2, 
         is.corr = FALSE, 
         tl.col = "black", 
         method = "color")
```

# Build Model

## Split Data

```{r split-data}
set.seed(1234) 
train <- sample_frac(duodata, 0.8)
test <- filter(duodata, !duodata$instance_id %in% train$instance_id) 
```

```{r build-rf}
m_rf <- randomForest(as_factor(label) ~ . 
                     -countries 
                     - instance_id 
                     - exercise_id
                     - session_id,
                     data = train, 
                     ntree = 100,
                     mtry = 5)

m_rf
```

```{r info-rf}
vip(m_rf)

#Error Rates
error_rates <- as_tibble(m_rf$err.rate)
error_rates <- error_rates |>
  mutate(Tree = 1:nrow(error_rates)) |>
  pivot_longer(cols = -Tree, names_to = "Type", values_to = "Error")
ggplot(error_rates, aes(x = Tree, 
                        y = Error, 
                        color = Type)) + 
  geom_line() +
  theme_bw()

plot(m_rf)
```

```{r predict-rf}
predicted_closed <- predict(m_rf, test)
confusion_rf <- table(predicted_closed, test$closed)
confusion_rf
accuracy_rf <- sum(diag(confusion_rf)) / nrow(test)
accuracy_rf
```

```{r build-boost-rf}
trControl = trainControl(method = "cv", number = 5)
set.seed(1234)
m_boost_rf <- train(label ~ . 
                     -countries 
                     - prompt 
                     - instance_id 
                     - exercise_id
                     - session_id, 
                   data = train, 
                   method = "xgbTree", 
                   trControl = trControl, 
                   verbose = FALSE, 
                   verbosity = 0)
```

```{r info-boost-rf}
summary(m_boost_rf)
plot(m_boost_rf)
print(m_boost_rf)
varImp(m_boost_rf)
```

```{r predict-rf}
predicted_closed <- predict(m_boost_rf, test)
confusion_boost_rf <- table(predicted_closed, test$closed)
confusion_boost_rf
accuracy_boost_rf <- sum(diag(confusion_rf)) / nrow(test)
accuracy_boost_rf
```

# Matias Idea for Missing Listening Prompt Data

```{r}
duodata |> 
  dplyr::select(-instance_id, 
                -part_of_speech, 
                -contains('dependency'), 
                -countries) |> 
  group_by(exercise_id) |> 
  mutate(exercise_accuracy = mean(label)) |> 
  ungroup() |> 
  filter(format == 'listen') |> 
  filter(exercise_accuracy == 1) |> 
  mutate(prompt = if_else(is.na(prompt), 'identifiable', prompt))

#If we can get the exact prompt, we can match it to users who got it wrong (ask Sanne!)

#pivot wide, merge the variables into one variable (use unite to combine them into one variable)

#Could we also just remove prompt? 
```
