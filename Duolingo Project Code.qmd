---
title: "Duolingo Project Code"
author: "Michael Chrzan, Alexa Sparks, Tracy Li"
format: html
editor: visual
---

# Introduction

Given a history of errors made by learners of a second language, the task is to predict errors that they are likely to make at arbitrary points in the future.

# Research Questions

Our main research question is: What features best predict second-language-learners accuracy rates for correctly identifying a word in a Duolingo exercise?

In addressing that question, we are also considering the following questions:

-   What other user characteristics can we deduce from the provided data? How well do those derived characteristics predict user accuracy?

-   Do certain features better predict word-accuracy versus exercise-accuracy?

# Setup

## Libraries

Which libraries will we use and why?

```{r libraries}
library(tidyverse)
library(skimr)
library(naniar)
library(gt)
library(MASS)
library(glmnet)
```

## Import Data

```{r import-data}
duodata <- read_csv("data_flatformat.csv")
```

# Examine Data

```{r view-data}
glimpse(duodata)
duoskim <- skim(duodata)
duoskim
```

## Missing Data

```{r viz-missing}
#Setting sample since these packaged functions throw errors for large data
set.seed(1234)
duosample <- sample_n(duodata, 2622956/54)

vis_miss(duosample, 
         show_perc = TRUE) 
miss_var_summary(duosample)

duosample_mis <- duosample |> 
  select(prompt, time, client, format, session)

gg_miss_var(duosample_mis)
gg_miss_var(duosample_mis, 
            facet = client, 
            show_pct = TRUE)
gg_miss_var(duosample_mis, 
            facet = format, 
            show_pct = TRUE)
gg_miss_var(duosample_mis, 
            facet = session, 
            show_pct = TRUE)
gg_miss_upset(duosample_mis)

```

```{r mis-prompt}
#Examining Missiningness Related to Prompt and Time with Other Variables
#Is all the missing prompt data in format? Appears so (NOTE, not the sample, full dataset)

#Prompt
duodata |> 
  dplyr::select(prompt, format, session, client) |> 
  group_by(format, session, client) |> 
  miss_var_summary() |>
  arrange(desc(pct_miss))

#Time
duodata |> 
  dplyr::select(time, format, session, client) |> 
  group_by(format, session, client) |> 
  miss_var_summary() |>
  arrange(desc(pct_miss))
```

```{r impute-data}
duodata |> 
  dplyr::select(-instance_id, 
                -part_of_speech, 
                -contains('dependency'), 
                -countries) |> 
  group_by(exercise_id) |> 
  mutate(exercise_accuracy = mean(label)) |> 
  ungroup() |> 
  filter(format == 'listen') |> 
  filter(exercise_accuracy == 1) |> 
  mutate(prompt = if_else(is.na(prompt), 'identifiable', prompt))

#If we can get the exact prompt, we can match it to users who got it wrong (ask Sanne!)

#Could we also just remove prompt? 
```

```{r remove-mis-remaining}
#Prompt missing data is entirely on the listen format
#Time missing data seems to mostly be a problem on iOS but Michael can't see a pattern beyond that. 

#duodata <- duodata |> na.omit()
```

## Distributions

```{r data-manipulations}
#Session Accuracy and Session Time for each User for their entire time
duodata |> 
  group_by(user) |> 
  mutate(avg_accuracy_user = mean(label), 
         avg_session_time_user = mean(time), 
         avg_days_user = mean(days)) |>
  ungroup() |> 
  dplyr::select(user, session_id, exercise_id, contains('avg'))

#Session Accuracy and Session Time per Day
#Is the day variable aligned for each user? i.e. If I skipped 2 days, is my day 2 the same as a continuous user's day 4? 
duodata |> 
  mutate(days_count = round(days)) |>
  group_by(user, days_count) |> 
  mutate(avg_daily_accuracy_user = mean(label), 
         avg_daily_session_time_user = mean(time)) |> 
  ungroup() |> 
  dplyr::select(user, days, session_id, exercise_id, contains('avg'))

#Number of Exercises per Session
duodata |> 
  group_by(session_id) |>
  mutate(num_session_exercises = n_distinct(exercise_index)) |> 
  ungroup() |> 
  group_by(user) |> 
  mutate(avg_exer_per_session = mean(num_session_exercises)) |> 
  ungroup() |> 
  dplyr::select(user, session_id, num_session_exercises, avg_exer_per_session)

  
#Number of Exercises per Day
duodata |> 
  group_by(session_id) |>
  mutate(num_session_exercises = n_distinct(exercise_index)) |> 
  ungroup() |> 
  mutate(days_count = round(days)) |>
  group_by(user, days_count) |> 
  mutate(avg_daily_num_exercise = mean(num_session_exercises)) |> 
  dplyr::select(user, exercise_id, days_count, num_session_exercises, avg_daily_num_exercise)

#Exercise Accuracy??
duodata |> 
  group_by(exercise_id) |> 
  mutate(avg_user_exer_accuracy = mean(label)) |> 
  ungroup() |> 
  dplyr::select(user, exercise_id, avg_user_exer_accuracy)


#Removing Variables Not Included in our final analysis
duodata |> 
  dplyr::select(-country, -prompt)
```

```{r viz-variable-dist}
duodata |>
  pivot_longer(cols = c(part_of_speech, 
                        client, 
                        session, 
                        format),
               names_to = "variable",
               values_to = "value") |>
  ggplot() +
  geom_bar(aes(value)) +
  facet_wrap(. ~ variable, 
             scales = "free") + 
  coord_flip()

duodata |>
  pivot_longer(cols = c(dependency_label, 
                        countries),
               names_to = "variable",
               values_to = "value") |>
  ggplot() +
  geom_bar(aes(value)) +
  facet_wrap(. ~ variable, 
             scales = "free") + 
  coord_flip()

duodata |>
  pivot_longer(cols = where(is.numeric), 
               names_to = "variable",
               values_to = "value") |>
  ggplot() +
  geom_histogram(aes(value)) +
  facet_wrap(. ~ variable, 
             scales = "free") 

#Should we include folks at 0 days?
```

```{r check-countries}
distinct(duodata, countries)
#How should we handle multiple countries? 
```

# Split Data

```{r split-data}
set.seed(1234) 
train <- sample_frac(duodata, 0.8)
test <- filter(duodata, !duodata$instance_id %in% train$instance_id) 
```

```{r logit}

#How do we predict for specific users? Do we need to pivot wide?? 
m_logit <- glm(label ~ part_of_speech + 
                 days + 
                 client + 
                 session + 
                 format + 
                 time,
               data = train, 
               family = binomial(link = "logit"))

summary(m_logit)
```

```{r ridge}
train_matrix_x <- model.matrix(label ~ part_of_speech + 
                                 days + 
                                 client + 
                                 session + 
                                 format + 
                                 time,
                               data = train)


train_matrix_y <- train |> 
  dplyr::select(label)  |> 
  as.matrix()

m_ridge <- cv.glmnet(x = train_matrix_x,
                     y = train_matrix_y,
                     alpha = 0)

plot(m_ridge, "lambda")

m_ridge_coefs <- coef(m_ridge, s = "lambda.1se") 
summary_m_ridge <- summary(m_ridge_coefs)

m_ridge_coefs <- tibble(variable = rownames(m_ridge_coefs)[summary_m_ridge$i],
                        coefficient = summary_m_ridge$x) |> 
  filter(variable != "(Intercept)")

ggplot(m_ridge_coefs, 
       aes(y = variable, 
           x = coefficient)) +
  geom_segment(aes(y = variable,
                   yend = variable, 
                   x = 0, 
                   xend = coefficient)) +
  geom_point(size = 3) +
  geom_vline(xintercept = 0, 
             linetype = "dotted", 
             color = "grey",
             linewidth = 0.75) +
  theme_bw()
```

```{r lasso}
m_lasso <- cv.glmnet(x = train_matrix_x,
                     y = train_matrix_y,
                     alpha = 1)

m_lasso_coefs <- coef(m_lasso, "lambda.1se") 
summary_m_lasso <- summary(m_lasso_coefs)

m_lasso_coefs <- tibble(variable = 
                        rownames(m_lasso_coefs)[summary_m_lasso$i],
                      coefficient = summary_m_lasso$x) |> 
  filter(variable != "(Intercept)")

ggplot(m_lasso_coefs, 
       aes(y = variable, 
           x = coefficient)) +
  geom_segment(aes(y = variable,
                   yend = variable, 
                   x = 0, 
                   xend = coefficient)) +
  geom_point(size = 4, 
             alpha = 0.6) +
  theme_bw() 
```

```{r viz for seminar}
#Create a viz of x = time, y = accuracy measured by proportion of label that is 1
#Could also show if accuracy changes based on session

#SOMETHING VERY STRANGE HAPPENING HERE w/ iOS-------
duosample |> 
  group_by(user, session_id) |> 
  mutate(user_session_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = days, 
             y = user_session_accuracy, 
             color = session)) + 
  geom_smooth() + 
  facet_grid(~client) +
  labs(title = 'User Session Accuracy Over Time', 
       subtitle = '',
       x = 'Session Type', 
       y = 'Session Accuracy') + 
  theme_minimal() 
#--------------------------------------------------

duodata |> 
  group_by(session) |> 
  summarise(session_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = session, 
             y = session_accuracy, 
             fill = session)) + 
  geom_col() +
  scale_fill_manual(values = c('#7ac70c', '#7ac70c', '#7ac70c')) +
  labs(title = 'Practice Makes Perfect?', 
       subtitle = 'Average Session Accuracy based on Session Type',
       x = 'Session Type', 
       y = 'Session Accuracy') + 
  theme_minimal() +
  theme(legend.position = 'none') +
  coord_flip()

duodata |> 
  group_by(session_id) |> 
  mutate(session_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = days, 
             y = session_accuracy, 
             color = session)) + 
  geom_smooth() + 
  labs(title = 'It All Adds Up', 
       subtitle = 'Session Accuracy Over Time',
       x = 'Days Since Starting Duolingo', 
       y = 'Session Accuracy', 
       color = 'Session Type') + 
  theme_minimal() + 
  theme(legend.position = 'bottom')

duodata |> 
  group_by(session_id) |> 
  mutate(session_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = days, 
             y = session_accuracy)) + 
  geom_smooth() + 
  labs(title = 'It All Adds Up', 
       subtitle = 'Session Accuracy Over Time',
       x = 'Days Since Starting Duolingo', 
       y = 'Session Accuracy', 
       color = 'Session Type') + 
  theme_minimal() + 
  theme(legend.position = 'bottom')


#Test Outs------------------------------------------------------
duosample |> 
  group_by(user) |> 
  mutate(user_accuracy = sum(label == 1)/sum(!is.na(label))) |> 
  ungroup() |> 
  ggplot(aes(x = user_accuracy)) +
  geom_histogram() + 
  labs(title = 'Distribution of User Accuracy')


duosample |> 
  group_by(user, exercise_id) |> 
  mutate(user_exer_accuracy = mean(label)) |> 
  ungroup() |> 
  ggplot(aes(x = days, 
             y = user_exer_accuracy)) +
  geom_smooth() + 
  labs(title = 'User Exercise Accuracy Over Time')

duosample |> 
  group_by(session_id) |> 
  mutate(avg_session_accuracy = mean(label), 
         avg_session_time = mean(time)) |> 
  ungroup() |> 
  ggplot(aes(x = avg_session_time, 
             y = avg_session_accuracy, 
             color = session)) + 
  geom_smooth() + 
  labs(title = 'Session Accuracy vs Session Length', 
       subtitle = '',
       x = 'Average Time for the Session', 
       y = 'Average Session Accuracy', 
       color = 'Session Type') + 
  theme_minimal() +
  theme(legend.position = 'bottom')
```

# Matias Idea for Missing Listening Prompt Data

```{r}
duodata |> 
  dplyr::select(-instance_id, 
                -part_of_speech, 
                -contains('dependency'), 
                -countries) |> 
  group_by(exercise_id) |> 
  mutate(exercise_accuracy = mean(label)) |> 
  ungroup() |> 
  filter(format == 'listen') |> 
  filter(exercise_accuracy == 1) |> 
  mutate(prompt = if_else(is.na(prompt), 'identifiable', prompt))

#If we can get the exact prompt, we can match it to users who got it wrong (ask Sanne!)

#pivot wide, merge the variables into one variable (use unite to combine them into one variable)

#Could we also just remove prompt? 
```
